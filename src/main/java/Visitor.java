import java.util.ArrayList;

/**
 * Subclass of the visitor class which is auto-generated by the ANTLR recognizer.
 */
public class Visitor extends GrammarSampleBaseVisitor<ThompsonNFA> {

    /**
     * State id's used as name.
     */
    int stateID = 0;

    /**
     * This is the automaton which will check if the strings given in input are generated by it.
     */
    ThompsonNFA init;

    /**
     * Main lexer rule that calls 'regex' rule and 'stringList' rule.
     * @param ctx the parse tree.
     * @return Thompson nfa and the result of the strings given in input.
     */
    @Override
    public ThompsonNFA visitInit(GrammarSampleParser.InitContext ctx) {
        init = visit(ctx.regex());
        visit(ctx.stringList());
        return init;
    }

    /**
     * Regex rule which is basically the union operation.
     * @param ctx the parse tree.
     * @return the unionized NFA.
     */
    @Override
    public ThompsonNFA visitRegex(GrammarSampleParser.RegexContext ctx) {
        ArrayList<ThompsonNFA> regex = new ArrayList<>();
        ThompsonNFA union = new ThompsonNFA();

        for(int i = 0; i < ctx.concat().size(); i++)
            regex.add(visit(ctx.concat(i)));

        if(regex.size() == 1)
            union = regex.get(0);
        else
            union.unionGenerator(regex, new NFAState(String.valueOf(stateID++), true, false, new ArrayList<>()),
                    new NFAState(String.valueOf(stateID++), false, true, new ArrayList<>()));

        return union;
    }

    /**
     * Concat rule that concat multiple sub NFA's together.
     * @param ctx the parse tree
     * @return the concatenated NFA's.
     */
    @Override
    public ThompsonNFA visitConcat(GrammarSampleParser.ConcatContext ctx) {
        ArrayList<ThompsonNFA> toConcat = new ArrayList<>();
        ThompsonNFA concat = new ThompsonNFA();

        for(int i = 0; i < ctx.kleene().size(); i++) {
            toConcat.add(visit(ctx.kleene(i)));
        }

        if(toConcat.size() == 1)
            concat = toConcat.get(0);
        else
            concat.concatGenerator(toConcat);

        return concat;
    }

    /**
     * Kleene rule with the kleene star allowing a NFA to create n times sub NFA(s).
     * @param ctx the parse tree.
     * @return the NFA with kleene star.
     */
    @Override
    public ThompsonNFA visitStar(GrammarSampleParser.StarContext ctx) {
        ThompsonNFA star = visit(ctx.basic());
        NFAState newKleeneStart = new NFAState(String.valueOf(stateID++), true, false, new ArrayList<>());
        NFAState newKleeneEnd = new NFAState(String.valueOf(stateID++), false, true, new ArrayList<>());
        star.kleeneGenerator(newKleeneStart, newKleeneEnd);
        return star;
    }

    /**
     * Kleene rule without the kleene star so basically calling the basic rule.
     * @param ctx the parse tree
     * @return passes the basic NFA to 'parent' rule.
     */
    @Override
    public ThompsonNFA visitNoStar(GrammarSampleParser.NoStarContext ctx) {
        return visit(ctx.basic());
    }

    /**
     * Basic rule that generates NFA with a symbol.
     * @param ctx the parse tree
     * @return a basic nfa.
     */
    @Override
    public ThompsonNFA visitBasicAlphabet(GrammarSampleParser.BasicAlphabetContext ctx) {
        NFAState start = new NFAState(String.valueOf(stateID++), true, false, new ArrayList<>());
        NFAState end = new NFAState(String.valueOf(stateID++), false, true, new ArrayList<>());
        ThompsonNFA nfa = new ThompsonNFA(start, end);
        nfa.basicAlphabetGenerator(ctx.getText());
        return nfa;
    }

    /**
     * Basic rule that generates NFA with "epsilon".
     * @param ctx the parse tree
     * @return a basic nfa.
     */
    @Override
    public ThompsonNFA visitBasicEpsilon(GrammarSampleParser.BasicEpsilonContext ctx) {
        NFAState start = new NFAState(String.valueOf(stateID++), true, false, new ArrayList<>());
        NFAState end = new NFAState(String.valueOf(stateID++), false, true, new ArrayList<>());
        ThompsonNFA nfa = new ThompsonNFA(start, end);
        nfa.basicEpsilonGenerator(ctx.getText());
        return nfa;
    }

    /**
     * Basic rule that generates a sub-expression inside parenthesis. (regex)
     * @param ctx the parse tree
     * @return the sub-expression.
     */
    @Override
    public ThompsonNFA visitBasicRegex(GrammarSampleParser.BasicRegexContext ctx) {
        return visit(ctx.regex());
    }

    /**
     * Second half of the input that contain all strings. Calls the parent method which basically visits its children.
     * @param ctx the parse tree
     * @return whatever children returned, but in our case always null.
     */
    @Override
    public ThompsonNFA visitStringList(GrammarSampleParser.StringListContext ctx) {
        return super.visitStringList(ctx);
    }

    /**
     * Calls the accept method of the NFA to check if the string can be generated by said NFA. The output is stored
     * in the NFA itself.
     * @param ctx the parse tree
     * @return null because the output of the operation is stored inside NFA so there is no need.
     */
    @Override
    public ThompsonNFA visitString(GrammarSampleParser.StringContext ctx) {
        init.accept(ctx.getText());
        return null;
    }
}
